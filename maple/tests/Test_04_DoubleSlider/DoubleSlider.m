% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: DoubleSlider
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef DoubleSlider < Indigo.DAE.Implicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_m = 1.0;
    m_J = 1.0;
    m_g = 9.81;
    m_ell = 1.0;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = DoubleSlider( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 8;
      num_veil = 1;
      num_invs = 6;
      this = this@Indigo.DAE.Implicit('DoubleSlider', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_m = varargin{1}.m;
        this.m_J = varargin{1}.J;
        this.m_g = varargin{1}.g;
        this.m_ell = varargin{1}.ell;
      elseif (nargin == 4)
        this.m_m = varargin{1};
        this.m_J = varargin{2};
        this.m_g = varargin{3};
        this.m_ell = varargin{4};
      else
        error('wrong number of input arguments.');
      end
    end % DoubleSlider
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_F = F( this, in_1, in_2, ~, ~ )
      % Evaluate the function F.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      x_dot = in_2(1);
      y_dot = in_2(2);
      theta_dot = in_2(3);
      u_dot = in_2(4);
      v_dot = in_2(5);
      omega_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      out_1 = -u + x_dot;
      out_2 = -v + y_dot;
      out_3 = u_dot * m + lambda__1;
      out_4 = g * m + v_dot * m + lambda__2;
      out_5 = -omega + theta_dot;
      t4 = sin(theta);
      t5 = ell * t4;
      t7 = cos(theta);
      t10 = omega_dot * J;
      out_6 = lambda__2 * ell * t7 - lambda__1 * t5 + 2 * t10;
      t13 = omega ^ 2;
      t16 = ell * lambda__1;
      t18 = t7 ^ 2;
      t25 = ell * theta_dot;
      t28 = ell ^ 2;
      t30 = m * t28 * t18;
      t32 = 4 * J;
      t36 = omega * t10;
      t45 = 0.1e1 / m;
      t47 = 0.1e1 / J;
      out_7 = t47 * t45 * (-2 * t25 * m * (t13 * t4 * J - t16 * t7 * t4 + ell * lambda__2 * t18 - ell * lambda__2 / 2) + lambda__1_dot * (m * t28 - t30 + t32) + 4 * ell * (t36 - ell * lambda__2_dot * t4 / 4) * m * t7) / 2;
      out_8 = t47 * t45 * (2 * t25 * m * (-ell * lambda__1 * t18 + t7 * (t13 * J - lambda__2 * t5) + t16 / 2) + lambda__2_dot * (t30 + t32) + 4 * t5 * m * (t36 - t7 * ell * lambda__1_dot / 4)) / 2;

      % Store outputs
      out_F = zeros(8, 1);
      out_F(1) = out_1;
      out_F(2) = out_2;
      out_F(3) = out_3;
      out_F(4) = out_4;
      out_F(5) = out_5;
      out_F(6) = out_6;
      out_F(7) = out_7;
      out_F(8) = out_8;
    end % F
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x = JF_x( this, in_1, in_2, ~, ~ )
      % Evaluate the Jacobian of F with respect to x.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      ell = this.m_ell;

      % Extract inputs
      theta = in_1(3);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      theta_dot = in_2(3);
      omega_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      t1 = cos(theta);
      t2 = ell * t1;
      t4 = sin(theta);
      t5 = ell * t4;
      t6 = lambda__2 * t5;
      out_6_3 = -lambda__1 * t2 - t6;
      t7 = omega ^ 2;
      t8 = t7 * J;
      t10 = t1 ^ 2;
      t13 = t4 ^ 2;
      t16 = t1 * t4;
      t22 = ell * theta_dot;
      t25 = ell ^ 2;
      t26 = t25 * t1;
      t27 = t4 * m;
      t31 = omega_dot * J;
      t32 = omega * t31;
      t44 = 0.1e1 / m;
      t46 = 0.1e1 / J;
      out_7_3 = t46 * t44 * (-2 * t22 * m * (-ell * lambda__1 * t10 + ell * lambda__1 * t13 - 2 * lambda__2 * ell * t16 + t1 * t8) + 2 * lambda__1_dot * t27 * t26 - 4 * ell * (t32 - ell * lambda__2_dot * t4 / 4) * t27 - t25 * lambda__2_dot * m * t10) / 2;
      out_8_3 = t46 * t44 * (2 * t22 * m * (2 * lambda__1 * ell * t16 - ell * lambda__2 * t10 - t4 * (t8 - t6)) - 2 * lambda__2_dot * t27 * t26 + m * t13 * t25 * lambda__1_dot + 4 * t2 * m * (t32 - t1 * ell * lambda__1_dot / 4)) / 2;
      out_1_4 = -1;
      out_2_5 = -1;
      out_5_6 = -1;
      t78 = m * ell * theta_dot;
      out_7_6 = t46 * t44 * (-4 * t78 * omega * t4 * J + 4 * ell * t31 * m * t1) / 2;
      out_8_6 = t46 * t44 * (4 * t78 * t1 * omega * J + 4 * ell * t27 * t31) / 2;
      out_3_7 = 1;
      out_6_7 = -t5;
      out_7_7 = t46 * theta_dot * t25 * t16;
      t100 = -ell * t10 + ell / 2;
      t102 = t46 * theta_dot;
      out_8_7 = t102 * ell * t100;
      out_4_8 = 1;
      out_6_8 = t2;
      out_7_8 = t102 * ell * t100;
      out_8_8 = -out_7_7;

      % Store outputs
      out_JF_x = zeros(8, 8);
      out_JF_x(6, 3) = out_6_3;
      out_JF_x(7, 3) = out_7_3;
      out_JF_x(8, 3) = out_8_3;
      out_JF_x(1, 4) = out_1_4;
      out_JF_x(2, 5) = out_2_5;
      out_JF_x(5, 6) = out_5_6;
      out_JF_x(7, 6) = out_7_6;
      out_JF_x(8, 6) = out_8_6;
      out_JF_x(3, 7) = out_3_7;
      out_JF_x(6, 7) = out_6_7;
      out_JF_x(7, 7) = out_7_7;
      out_JF_x(8, 7) = out_8_7;
      out_JF_x(4, 8) = out_4_8;
      out_JF_x(6, 8) = out_6_8;
      out_JF_x(7, 8) = out_7_8;
      out_JF_x(8, 8) = out_8_8;
    end % JF_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x_dot = JF_x_dot( this, in_1, ~, ~, ~ )
      % Evaluate the Jacobian of F with respect to x_dot.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      ell = this.m_ell;

      % Extract inputs
      theta = in_1(3);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      out_1_1 = 1;
      out_2_2 = 1;
      out_5_3 = 1;
      t1 = sin(theta);
      t3 = omega ^ 2;
      t5 = cos(theta);
      t6 = t5 * t1;
      t7 = ell * lambda__1;
      t9 = t5 ^ 2;
      t16 = 0.1e1 / J;
      out_7_3 = -t16 * ell * (t3 * t1 * J - t7 * t6 + ell * lambda__2 * t9 - ell * lambda__2 / 2);
      t21 = ell * t1;
      out_8_3 = t16 * ell * (-ell * lambda__1 * t9 + t5 * (t3 * J - lambda__2 * t21) + t7 / 2);
      out_3_4 = m;
      out_4_5 = m;
      out_6_6 = 2 * J;
      out_7_6 = 2 * omega * ell * t5;
      out_8_6 = 2 * omega * t21;
      t31 = ell ^ 2;
      t33 = m * t31 * t9;
      t35 = 4 * J;
      t37 = 0.1e1 / m;
      out_7_7 = t16 * t37 * (m * t31 - t33 + t35) / 2;
      out_8_7 = -t16 * t31 * t6 / 2;
      out_7_8 = out_8_7;
      out_8_8 = t16 * t37 * (t33 + t35) / 2;

      % Store outputs
      out_JF_x_dot = zeros(8, 8);
      out_JF_x_dot(1, 1) = out_1_1;
      out_JF_x_dot(2, 2) = out_2_2;
      out_JF_x_dot(5, 3) = out_5_3;
      out_JF_x_dot(7, 3) = out_7_3;
      out_JF_x_dot(8, 3) = out_8_3;
      out_JF_x_dot(3, 4) = out_3_4;
      out_JF_x_dot(4, 5) = out_4_5;
      out_JF_x_dot(6, 6) = out_6_6;
      out_JF_x_dot(7, 6) = out_7_6;
      out_JF_x_dot(8, 6) = out_8_6;
      out_JF_x_dot(7, 7) = out_7_7;
      out_JF_x_dot(8, 7) = out_8_7;
      out_JF_x_dot(7, 8) = out_7_8;
      out_JF_x_dot(8, 8) = out_8_8;
    end % JF_x_dot
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_v = JF_v( ~, ~, ~, ~, ~ )
      % Evaluate the Jacobian of F with respect to v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_JF_v = zeros(8, 1);
    end % JF_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( this, in_1, ~ )
      % Evaluate the the veils v.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      ell = this.m_ell;

      % Extract inputs
      theta = in_1(3);

      % Evaluate function
      t1 = ell ^ 2;
      t6 = m ^ 2;
      t7 = t1 * t6;
      t8 = cos(theta);
      t9 = t8 ^ 2;
      V_y58KN_1 = 0.1e1 / (4 * m * J - t9 * t7 + t7) * (4 * m * t1 + 16 * J);

      % Store outputs
      out_v = zeros(1, 1);
      out_v(1) = V_y58KN_1;
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( this, in_1, ~, ~ )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      ell = this.m_ell;

      % Extract inputs
      theta = in_1(3);

      % Evaluate function
      D_V_y58KN_1_1 = 0;
      D_V_y58KN_1_2 = 0;
      t1 = ell ^ 2;
      t6 = m ^ 2;
      t7 = t1 * t6;
      t8 = cos(theta);
      t9 = t8 ^ 2;
      t14 = (4 * m * J - t9 * t7 + t7) ^ 2;
      t19 = sin(theta);
      D_V_y58KN_1_3 = -2 * t19 * t8 * t1 * t6 / t14 * (4 * m * t1 + 16 * J);
      D_V_y58KN_1_4 = 0;
      D_V_y58KN_1_5 = 0;
      D_V_y58KN_1_6 = 0;
      D_V_y58KN_1_7 = 0;
      D_V_y58KN_1_8 = 0;

      % Store outputs
      out_Jv_x = zeros(1, 8);
      out_Jv_x(1, 1) = D_V_y58KN_1_1;
      out_Jv_x(1, 2) = D_V_y58KN_1_2;
      out_Jv_x(1, 3) = D_V_y58KN_1_3;
      out_Jv_x(1, 4) = D_V_y58KN_1_4;
      out_Jv_x(1, 5) = D_V_y58KN_1_5;
      out_Jv_x(1, 6) = D_V_y58KN_1_6;
      out_Jv_x(1, 7) = D_V_y58KN_1_7;
      out_Jv_x(1, 8) = D_V_y58KN_1_8;
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, ~, ~ )
      % Calculate the residual of the invariants h.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      t1 = cos(theta);
      t2 = ell * t1;
      out_1 = -t2 - 2 * x;
      t4 = sin(theta);
      t5 = ell * t4;
      out_2 = -t5 - 2 * y;
      out_3 = -omega * t5 + 2 * u;
      out_4 = omega * t2 + 2 * v;
      t11 = omega ^ 2;
      t16 = t1 * t4;
      t17 = ell ^ 2;
      t21 = t1 ^ 2;
      t23 = m * t17;
      t26 = m * t17 * lambda__1;
      t30 = 0.1e1 / m;
      t32 = 0.1e1 / J;
      out_5 = t32 * t30 * (2 * J * m * t11 * t2 - m * t17 * lambda__2 * t16 - t23 * lambda__1 * t21 + 4 * lambda__1 * J + t26) / 2;
      out_6 = t32 * t30 * (t23 * lambda__2 * t21 - t26 * t16 + 2 * (t11 * ell * m * t4 + 2 * g * m + 2 * lambda__2) * J) / 2;

      % Store outputs
      out_h = zeros(6, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
      out_h(3) = out_3;
      out_h(4) = out_4;
      out_h(5) = out_5;
      out_h(6) = out_6;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, ~, ~ )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      ell = this.m_ell;

      % Extract inputs
      theta = in_1(3);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      out_1_1 = -2;
      out_2_2 = -2;
      t1 = sin(theta);
      out_1_3 = ell * t1;
      t2 = cos(theta);
      t3 = ell * t2;
      out_2_3 = -t3;
      t4 = omega * t3;
      out_3_3 = -t4;
      t6 = omega * ell * t1;
      out_4_3 = -t6;
      t7 = omega ^ 2;
      t9 = J * m * t7;
      t12 = t2 ^ 2;
      t14 = ell ^ 2;
      t15 = m * t14;
      t17 = t2 * t1;
      t22 = t1 ^ 2;
      t26 = 0.1e1 / m;
      t28 = 0.1e1 / J;
      out_5_3 = t28 * t26 * (2 * m * t14 * lambda__1 * t17 - t15 * lambda__2 * t12 + t15 * lambda__2 * t22 - 2 * t9 * out_1_3) / 2;
      out_6_3 = t28 * t26 * (-2 * m * t14 * lambda__2 * t17 - t15 * lambda__1 * t12 + t15 * lambda__1 * t22 + 2 * t9 * t3) / 2;
      out_3_4 = 2;
      out_4_5 = 2;
      out_3_6 = -out_1_3;
      out_4_6 = t3;
      out_5_6 = 2 * t4;
      out_6_6 = 2 * t6;
      t44 = m * t14 * t12;
      t45 = 4 * J;
      out_5_7 = t28 * t26 * (-t44 + t15 + t45) / 2;
      out_6_7 = -t28 * t14 * t17 / 2;
      out_5_8 = out_6_7;
      out_6_8 = t28 * t26 * (t44 + t45) / 2;

      % Store outputs
      out_Jh_x = zeros(6, 8);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(1, 3) = out_1_3;
      out_Jh_x(2, 3) = out_2_3;
      out_Jh_x(3, 3) = out_3_3;
      out_Jh_x(4, 3) = out_4_3;
      out_Jh_x(5, 3) = out_5_3;
      out_Jh_x(6, 3) = out_6_3;
      out_Jh_x(3, 4) = out_3_4;
      out_Jh_x(4, 5) = out_4_5;
      out_Jh_x(3, 6) = out_3_6;
      out_Jh_x(4, 6) = out_4_6;
      out_Jh_x(5, 6) = out_5_6;
      out_Jh_x(6, 6) = out_6_6;
      out_Jh_x(5, 7) = out_5_7;
      out_Jh_x(6, 7) = out_6_7;
      out_Jh_x(5, 8) = out_5_8;
      out_Jh_x(6, 8) = out_6_8;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_pivots = pivots( this, in_1, in_2, ~ )
      % Calculate the pivoting values

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      ell = this.m_ell;

      % Extract inputs
      theta = in_1(3);
      V_y58KN_1 = in_2(1);

      % Evaluate function
      out_1_1 = 1;
      out_2_1 = 1;
      out_3_1 = 1;
      out_4_1 = m;
      out_5_1 = m;
      out_6_1 = 2 * J;
      out_7_1 = -1;
      out_8_1 = -1;
      out_1_2 = m;
      out_2_2 = m;
      out_3_2 = out_6_1;
      out_4_2 = 1;
      out_5_2 = 1;
      out_6_2 = 1;
      out_7_2 = -1;
      out_8_2 = -1;
      out_1_3 = 1;
      out_2_3 = 1;
      out_3_3 = m;
      out_4_3 = m;
      out_5_3 = 1;
      out_6_3 = out_3_2;
      out_7_3 = -1;
      out_8_3 = -1;
      out_1_4 = 1;
      out_2_4 = 1;
      out_3_4 = m;
      out_4_4 = m;
      out_5_4 = 1;
      out_6_4 = out_6_3;
      t1 = cos(theta);
      t2 = t1 ^ 2;
      t3 = ell ^ 2;
      out_7_4 = 0.1e1 / J / m * (-m * t2 * t3 + m * t3 + 4 * J) / 2;
      out_8_4 = V_y58KN_1 / 2;

      % Store outputs
      out_pivots = zeros(8, 4);
      out_pivots(1, 1) = out_1_1;
      out_pivots(2, 1) = out_2_1;
      out_pivots(3, 1) = out_3_1;
      out_pivots(4, 1) = out_4_1;
      out_pivots(5, 1) = out_5_1;
      out_pivots(6, 1) = out_6_1;
      out_pivots(7, 1) = out_7_1;
      out_pivots(8, 1) = out_8_1;
      out_pivots(1, 2) = out_1_2;
      out_pivots(2, 2) = out_2_2;
      out_pivots(3, 2) = out_3_2;
      out_pivots(4, 2) = out_4_2;
      out_pivots(5, 2) = out_5_2;
      out_pivots(6, 2) = out_6_2;
      out_pivots(7, 2) = out_7_2;
      out_pivots(8, 2) = out_8_2;
      out_pivots(1, 3) = out_1_3;
      out_pivots(2, 3) = out_2_3;
      out_pivots(3, 3) = out_3_3;
      out_pivots(4, 3) = out_4_3;
      out_pivots(5, 3) = out_5_3;
      out_pivots(6, 3) = out_6_3;
      out_pivots(7, 3) = out_7_3;
      out_pivots(8, 3) = out_8_3;
      out_pivots(1, 4) = out_1_4;
      out_pivots(2, 4) = out_2_4;
      out_pivots(3, 4) = out_3_4;
      out_pivots(4, 4) = out_4_4;
      out_pivots(5, 4) = out_5_4;
      out_pivots(6, 4) = out_6_4;
      out_pivots(7, 4) = out_7_4;
      out_pivots(8, 4) = out_8_4;
    end % pivots
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( ~, ~, ~, ~ )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(6, 1);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out = in_domain( ~, ~, ~ )
      out = true;
    end % in_domain
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % DoubleSlider

% That's All Folks!
