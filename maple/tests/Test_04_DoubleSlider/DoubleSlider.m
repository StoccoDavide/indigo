% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: DoubleSlider
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef DoubleSlider < Indigo.Systems.Implicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_m = 1.0;
    m_J = 1.0;
    m_g = 9.81;
    m_ell = 1.0;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = DoubleSlider( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 8;
      num_veil = 0;
      num_invs = 6;
      this = this@Indigo.Systems.Implicit('DoubleSlider', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_m = varargin{1}.m;
        this.m_J = varargin{1}.J;
        this.m_g = varargin{1}.g;
        this.m_ell = varargin{1}.ell;
      elseif (nargin == 4)
        this.m_m = varargin{1};
        this.m_J = varargin{2};
        this.m_g = varargin{3};
        this.m_ell = varargin{4};
      else
        error('wrong number of input arguments.');
      end
    end % DoubleSlider
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_F = F( this, in_1, in_2, in_3, t )
      % Evaluate the function F.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      x_dot = in_2(1);
      y_dot = in_2(2);
      theta_dot = in_2(3);
      u_dot = in_2(4);
      v_dot = in_2(5);
      omega_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      out_1 = -u + x_dot;
      out_2 = -v + y_dot;
      out_3 = m * u_dot + lambda__1;
      out_4 = m * g + m * v_dot + lambda__2;
      out_5 = -omega + theta_dot;
      t5 = cos(theta);
      t8 = sin(theta);
      out_6 = t5 * ell * lambda__2 - t8 * ell * lambda__1 + 2 * J * omega_dot;
      t12 = t5 * t8;
      t13 = ell ^ 2;
      t14 = 0.1e1 / J;
      t18 = t5 ^ 2;
      t20 = m * t13 * t18;
      t21 = 4 * J;
      t23 = 0.1e1 / m;
      t28 = omega ^ 2;
      t32 = t8 ^ 2;
      t33 = t32 * lambda__1;
      t38 = t8 * lambda__2;
      out_7 = -lambda__1_dot * t14 * t13 * t12 / 2 + lambda__2_dot * t14 * t23 * (t20 + t21) / 2 + t14 * (2 * t5 * t28 * J - ell * t18 * lambda__1 - 4 * ell * t5 * t38 + 3 * ell * t33) * ell * omega / 2;
      t49 = 0.1e1 / t8;
      t51 = 0.1e1 / t5;
      t54 = m ^ 2;
      t60 = t32 ^ 2;
      t62 = t13 * ell;
      t81 = J ^ 2;
      t85 = lambda__1 * J;
      out_8 = 2 * lambda__2_dot / t54 / t13 * t51 * t49 * (m * t13 * t32 + t20 + t21) + t14 * t23 / ell * t51 * t49 * (-3 * m * t62 * t5 * t32 * t8 * lambda__2 - 3 * m * t62 * t18 * t5 * t38 - 16 * ell * t12 * J * lambda__2 + 3 * m * t62 * t18 * t33 + 3 * m * t62 * t60 * lambda__1 - 4 * ell * t18 * t85 + 12 * ell * t32 * t85 + 8 * t5 * t28 * t81) * omega / 2;

      % Store outputs
      out_F = zeros(8, 1);
      out_F(1) = out_1;
      out_F(2) = out_2;
      out_F(3) = out_3;
      out_F(4) = out_4;
      out_F(5) = out_5;
      out_F(6) = out_6;
      out_F(7) = out_7;
      out_F(8) = out_8;
    end % F
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x = JF_x( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      x_dot = in_2(1);
      y_dot = in_2(2);
      theta_dot = in_2(3);
      u_dot = in_2(4);
      v_dot = in_2(5);
      omega_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      t2 = sin(theta);
      t5 = cos(theta);
      out_6_3 = -t2 * ell * lambda__2 - t5 * ell * lambda__1;
      t7 = t5 ^ 2;
      t8 = ell ^ 2;
      t9 = t8 * t7;
      t10 = 0.1e1 / J;
      t11 = lambda__1_dot * t10;
      t14 = t2 ^ 2;
      t15 = t8 * t14;
      t22 = ell * omega;
      t23 = omega ^ 2;
      t24 = t23 * J;
      t27 = t2 * lambda__1;
      t28 = t5 * ell;
      out_7_3 = -t11 * t9 / 2 + t11 * t15 / 2 - lambda__2_dot * t10 * t2 * t8 * t5 + t10 * (4 * ell * t14 * lambda__2 - 4 * ell * t7 * lambda__2 - 2 * t2 * t24 + 8 * t28 * t27) * t22 / 2;
      t44 = m * t15 + m * t9 + 4 * J;
      t45 = 0.1e1 / t14;
      t48 = m ^ 2;
      t51 = lambda__2_dot / t48 / t8;
      t54 = 0.1e1 / t7;
      t58 = t14 * t2;
      t60 = t8 * ell;
      t61 = m * t60;
      t62 = t5 * t61;
      t65 = t7 * t5;
      t67 = m * t60 * t65;
      t70 = t14 ^ 2;
      t74 = t7 ^ 2;
      t78 = J ^ 2;
      t79 = t23 * t78;
      t82 = lambda__1 * J;
      t83 = ell * t2;
      t84 = t5 * t83;
      t87 = J * lambda__2;
      t88 = ell * t7;
      t91 = ell * t14;
      t96 = 0.1e1 / t2;
      t98 = 0.1e1 / t5;
      t99 = 0.1e1 / ell;
      t101 = 0.1e1 / m;
      t103 = t10 * t101 * t99 * t98;
      t109 = t14 * lambda__1;
      t117 = t2 * lambda__2;
      t128 = 3 * m * t60 * t7 * t109 - 3 * t62 * t58 * lambda__2 + 3 * t61 * t70 * lambda__1 - 3 * t67 * t117 + 8 * t5 * t79 - 4 * t88 * t82 + 12 * t91 * t82 - 16 * t84 * t87;
      t129 = t128 * omega;
      t132 = t10 * t101 * t99;
      out_8_3 = -2 * t51 * t45 * t44 + 2 * t51 * t54 * t44 + t103 * t96 * (6 * t62 * t58 * lambda__1 + 3 * t61 * t70 * lambda__2 - 3 * t61 * t74 * lambda__2 - 8 * t2 * t79 + 6 * t67 * t27 + 32 * t84 * t82 - 16 * t88 * t87 + 16 * t91 * t87) * omega / 2 - t132 * t45 * t129 / 2 + t132 * t54 * t129 / 2;
      out_1_4 = -1;
      out_2_5 = -1;
      out_5_6 = -1;
      out_7_6 = t10 * (-ell * t7 * lambda__1 + 3 * ell * t109 - 4 * t28 * t117 + 2 * t5 * t24) * ell / 2 + 2 * t5 * t23 * ell;
      out_8_6 = t132 * t98 * t96 * t128 / 2 + 8 * t101 * t99 * t96 * t24;
      out_3_7 = 1;
      out_6_7 = -t83;
      out_7_7 = t10 * (3 * t91 - t88) * t22 / 2;
      out_8_7 = t103 * t96 * (12 * ell * t14 * J - 4 * ell * t7 * J + 3 * m * t60 * t70 + 3 * t61 * t7 * t14) * omega / 2;
      out_4_8 = 1;
      out_6_8 = t28;
      out_7_8 = -2 * t10 * t5 * t2 * omega * t8;
      out_8_8 = t103 * t96 * (-16 * out_6_8 * t2 * J - 3 * t61 * t65 * t2 - 3 * t61 * t5 * t58) * omega / 2;

      % Store outputs
      out_JF_x = zeros(8, 8);
      out_JF_x(6, 3) = out_6_3;
      out_JF_x(7, 3) = out_7_3;
      out_JF_x(8, 3) = out_8_3;
      out_JF_x(1, 4) = out_1_4;
      out_JF_x(2, 5) = out_2_5;
      out_JF_x(5, 6) = out_5_6;
      out_JF_x(7, 6) = out_7_6;
      out_JF_x(8, 6) = out_8_6;
      out_JF_x(3, 7) = out_3_7;
      out_JF_x(6, 7) = out_6_7;
      out_JF_x(7, 7) = out_7_7;
      out_JF_x(8, 7) = out_8_7;
      out_JF_x(4, 8) = out_4_8;
      out_JF_x(6, 8) = out_6_8;
      out_JF_x(7, 8) = out_7_8;
      out_JF_x(8, 8) = out_8_8;
    end % JF_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x_dot = JF_x_dot( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x_dot.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      x_dot = in_2(1);
      y_dot = in_2(2);
      theta_dot = in_2(3);
      u_dot = in_2(4);
      v_dot = in_2(5);
      omega_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      out_1_1 = 1;
      out_2_2 = 1;
      out_5_3 = 1;
      out_3_4 = m;
      out_4_5 = m;
      out_6_6 = 2 * J;
      t1 = sin(theta);
      t2 = cos(theta);
      t4 = ell ^ 2;
      t5 = 0.1e1 / J;
      out_7_7 = -t5 * t4 * t2 * t1 / 2;
      t9 = t2 ^ 2;
      t11 = m * t4 * t9;
      t12 = 4 * J;
      out_7_8 = t5 / m * (t11 + t12) / 2;
      t17 = t1 ^ 2;
      t26 = m ^ 2;
      out_8_8 = 2 / t26 / t4 / t2 / t1 * (m * t17 * t4 + t11 + t12);

      % Store outputs
      out_JF_x_dot = zeros(8, 8);
      out_JF_x_dot(1, 1) = out_1_1;
      out_JF_x_dot(2, 2) = out_2_2;
      out_JF_x_dot(5, 3) = out_5_3;
      out_JF_x_dot(3, 4) = out_3_4;
      out_JF_x_dot(4, 5) = out_4_5;
      out_JF_x_dot(6, 6) = out_6_6;
      out_JF_x_dot(7, 7) = out_7_7;
      out_JF_x_dot(7, 8) = out_7_8;
      out_JF_x_dot(8, 8) = out_8_8;
    end % JF_x_dot
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_v = JF_v( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to v.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      x_dot = in_2(1);
      y_dot = in_2(2);
      theta_dot = in_2(3);
      u_dot = in_2(4);
      v_dot = in_2(5);
      omega_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      % No body

      % Store outputs
      out_JF_v = zeros(8, 0);
    end % JF_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( this, in_1, t )
      % Evaluate the the veils v.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( this, in_1, in_2, t )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_Jv_x = zeros(0, 8);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, in_2, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      t1 = cos(theta);
      t2 = t1 * ell;
      out_1 = -t2 - 2 * x;
      t4 = sin(theta);
      t5 = t4 * ell;
      out_2 = -t5 - 2 * y;
      out_3 = -omega * t5 + 2 * u;
      out_4 = omega * t2 + 2 * v;
      t11 = omega ^ 2;
      t13 = J * m * t11;
      t16 = t4 ^ 2;
      t18 = ell ^ 2;
      t19 = m * t18;
      t23 = m * t18 * t1;
      t28 = 0.1e1 / m;
      t30 = 0.1e1 / J;
      out_5 = t30 * t28 * (t19 * t16 * lambda__1 - t23 * t4 * lambda__2 + 4 * lambda__1 * J + 2 * t13 * t2) / 2;
      t36 = t1 ^ 2;
      out_6 = t30 * t28 * (4 * J * g * m + t19 * t36 * lambda__2 - t23 * t4 * lambda__1 + 4 * J * lambda__2 + 2 * t13 * t5) / 2;

      % Store outputs
      out_h = zeros(6, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
      out_h(3) = out_3;
      out_h(4) = out_4;
      out_h(5) = out_5;
      out_h(6) = out_6;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      out_1_1 = -2;
      out_2_2 = -2;
      t1 = sin(theta);
      out_1_3 = t1 * ell;
      t2 = cos(theta);
      t3 = t2 * ell;
      out_2_3 = -t3;
      t4 = omega * t3;
      out_3_3 = -t4;
      t6 = omega * t1 * ell;
      out_4_3 = -t6;
      t7 = omega ^ 2;
      t9 = J * m * t7;
      t13 = ell ^ 2;
      t15 = m * t13 * t2;
      t18 = t2 ^ 2;
      t20 = m * t13;
      t22 = t1 ^ 2;
      t26 = 0.1e1 / m;
      t28 = 0.1e1 / J;
      out_5_3 = t28 * t26 * (2 * t15 * t1 * lambda__1 - t20 * t18 * lambda__2 + t20 * t22 * lambda__2 - 2 * t9 * out_1_3) / 2;
      out_6_3 = t28 * t26 * (-2 * t15 * t1 * lambda__2 - t20 * t18 * lambda__1 + t20 * t22 * lambda__1 + 2 * t9 * t3) / 2;
      out_3_4 = 2;
      out_4_5 = 2;
      out_3_6 = -out_1_3;
      out_4_6 = t3;
      out_5_6 = 2 * t4;
      out_6_6 = 2 * t6;
      t44 = 4 * J;
      out_5_7 = t28 * t26 * (m * t13 * t22 + t44) / 2;
      out_6_7 = -t28 * t13 * t2 * t1 / 2;
      out_5_8 = out_6_7;
      out_6_8 = t28 * t26 * (m * t13 * t18 + t44) / 2;

      % Store outputs
      out_Jh_x = zeros(6, 8);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(1, 3) = out_1_3;
      out_Jh_x(2, 3) = out_2_3;
      out_Jh_x(3, 3) = out_3_3;
      out_Jh_x(4, 3) = out_4_3;
      out_Jh_x(5, 3) = out_5_3;
      out_Jh_x(6, 3) = out_6_3;
      out_Jh_x(3, 4) = out_3_4;
      out_Jh_x(4, 5) = out_4_5;
      out_Jh_x(3, 6) = out_3_6;
      out_Jh_x(4, 6) = out_4_6;
      out_Jh_x(5, 6) = out_5_6;
      out_Jh_x(6, 6) = out_6_6;
      out_Jh_x(5, 7) = out_5_7;
      out_Jh_x(6, 7) = out_6_7;
      out_Jh_x(5, 8) = out_5_8;
      out_Jh_x(6, 8) = out_6_8;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      m = this.m_m;
      J = this.m_J;
      g = this.m_g;
      ell = this.m_ell;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      theta = in_1(3);
      u = in_1(4);
      v = in_1(5);
      omega = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(6, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % DoubleSlider

% That's All Folks!
