% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: CrankRod
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef CrankRod < Indigo.Systems.Explicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_m = 1.0;
    m_g = 9.81;
    m_l = 1.0;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = CrankRod( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 14;
      num_veil = 0;
      num_invs = 12;
      this = this@Indigo.Systems.Explicit('CrankRod', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_m = varargin{1}.m;
        this.m_g = varargin{1}.g;
        this.m_l = varargin{1}.l;
      elseif (nargin == 3)
        this.m_m = varargin{1};
        this.m_g = varargin{2};
        this.m_l = varargin{3};
      else
        error('wrong number of input arguments.');
      end
    end % CrankRod
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_f = f( this, in_1, in_2, t )
      % Evaluate the function f.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      out_1 = u__1;
      out_2 = v__1;
      out_3 = u__2;
      out_4 = v__2;
      out_5 = omega;
      t2 = 0.1e1 / m;
      out_6 = t2 * (lambda__1 - lambda__3);
      out_7 = t2 * (-g * m + lambda__2);
      out_8 = lambda__3 * t2;
      t5 = sin(theta);
      t6 = 0.1e1 / t5;
      t9 = cos(theta);
      t11 = omega ^ 2;
      out_10 = -(m * t11 * l * t9 + lambda__1 - lambda__3) / l * t6 * t2;
      t17 = t5 ^ 2;
      t19 = t9 ^ 2;
      t24 = t19 ^ 2;
      t26 = l * m;
      t29 = t17 * lambda__1;
      t32 = t19 * t9;
      t35 = t17 * lambda__3;
      t46 = 0.1e1 / (5 * t17 + t19);
      t48 = t46 * t6 * (3 * m * l * t19 * t17 * t11 + 3 * t26 * t24 * t11 - t17 * t5 * lambda__2 + 2 * t9 * t29 + 3 * t32 * lambda__1 - 3 * t32 * lambda__3 - 4 * t9 * t35) * omega;
      out_11 = 3 * t48;
      out_12 = t46 * (15 * m * l * t17 * t11 * t9 + 15 * t26 * t11 * t32 + lambda__2 * t5 * t9 + 16 * t19 * lambda__1 - 14 * t19 * lambda__3 + 15 * t29 - 15 * t35) * omega;
      out_13 = 2 * t48;

      % Store outputs
      out_f = zeros(14, 1);
      out_f(1) = out_1;
      out_f(2) = out_2;
      out_f(3) = out_3;
      out_f(4) = out_4;
      out_f(5) = out_5;
      out_f(6) = out_6;
      out_f(7) = out_7;
      out_f(8) = out_8;
      out_f(10) = out_10;
      out_f(11) = out_11;
      out_f(12) = out_12;
      out_f(13) = out_13;
    end % f
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jf_x = Jf_x( this, in_1, in_2, t )
      % Evaluate the Jacobian of f with respect to x.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      t1 = 0.1e1 / m;
      t2 = sin(theta);
      t3 = t2 ^ 2;
      t4 = 0.1e1 / t3;
      t6 = 0.1e1 / l;
      t7 = cos(theta);
      t8 = l * t7;
      t9 = omega ^ 2;
      out_10_5 = t7 * (m * t9 * t8 + lambda__1 - lambda__3) * t6 * t4 * t1 + t9;
      t17 = t7 ^ 2;
      t18 = t17 * t7;
      t23 = t3 * t2;
      t24 = t23 * t9;
      t37 = t3 * lambda__2;
      t42 = 0.1e1 / t2;
      t44 = 5 * t3 + t17;
      t45 = 0.1e1 / t44;
      t46 = t45 * t42;
      t47 = t46 * (-6 * m * l * t18 * t2 * t9 - 6 * m * t8 * t24 - 5 * t17 * t2 * lambda__1 + t17 * t2 * lambda__3 - 2 * t23 * lambda__1 + 4 * t23 * lambda__3 - 3 * t7 * t37) * omega;
      t52 = m * l * t17;
      t55 = t17 ^ 2;
      t57 = l * m;
      t60 = t3 * lambda__1;
      t65 = t3 * lambda__3;
      t71 = 3 * t52 * t3 * t9 + 3 * t57 * t55 * t9 + 3 * t18 * lambda__1 - 3 * t18 * lambda__3 - t23 * lambda__2 + 2 * t7 * t60 - 4 * t7 * t65;
      t72 = t71 * omega;
      t74 = t45 * t72 * t7 * t4;
      t76 = t44 ^ 2;
      t77 = 0.1e1 / t76;
      t79 = t7 * t77 * t72;
      out_11_5 = 3 * t47 - 3 * t74 - 24 * t79;
      t102 = m * l * t3;
      t113 = 15 * t102 * t9 * t7 + 15 * t57 * t9 * t18 + lambda__2 * t2 * t7 + 16 * t17 * lambda__1 - 14 * t17 * lambda__3 + 15 * t60 - 15 * t65;
      out_12_5 = t45 * (-15 * t2 * t57 * t9 * t17 - 2 * t2 * t7 * lambda__1 - 2 * t2 * t7 * lambda__3 + lambda__2 * t17 - 15 * t57 * t24 - t37) * omega - 8 * t7 * t2 * t77 * t113 * omega;
      out_13_5 = 2 * t47 - 2 * t74 - 16 * t79;
      out_1_6 = 1;
      out_2_7 = 1;
      out_3_8 = 1;
      out_4_9 = 1;
      out_5_10 = 1;
      out_10_10 = -2 * omega * t7 * t42;
      t127 = t3 * omega;
      t135 = t45 * t42 * t71 + t46 * (6 * t57 * t55 * omega + 6 * t52 * t127) * omega;
      out_11_10 = 3 * t135;
      t139 = omega * t7;
      out_12_10 = t45 * t113 + t45 * (30 * t57 * omega * t18 + 30 * t102 * t139) * omega;
      out_13_10 = 2 * t135;
      out_6_11 = t1;
      t146 = t6 * t42 * out_6_11;
      out_10_11 = -t146;
      t147 = t7 * t3;
      t149 = 3 * t18;
      t152 = t46 * (2 * t147 + t149) * omega;
      out_11_11 = 3 * t152;
      t154 = 15 * t3;
      out_12_11 = t45 * (16 * t17 + t154) * omega;
      out_13_11 = 2 * t152;
      out_7_12 = out_6_11;
      t157 = t45 * t127;
      out_11_12 = -3 * t157;
      out_12_12 = t45 * t2 * t139;
      out_13_12 = -2 * t157;
      out_6_13 = -out_7_12;
      out_8_13 = out_7_12;
      out_10_13 = t146;
      t164 = t46 * (-4 * t147 - t149) * omega;
      out_11_13 = 3 * t164;
      out_12_13 = t45 * (-14 * t17 - t154) * omega;
      out_13_13 = 2 * t164;

      % Store outputs
      out_Jf_x = zeros(14, 14);
      out_Jf_x(10, 5) = out_10_5;
      out_Jf_x(11, 5) = out_11_5;
      out_Jf_x(12, 5) = out_12_5;
      out_Jf_x(13, 5) = out_13_5;
      out_Jf_x(1, 6) = out_1_6;
      out_Jf_x(2, 7) = out_2_7;
      out_Jf_x(3, 8) = out_3_8;
      out_Jf_x(4, 9) = out_4_9;
      out_Jf_x(5, 10) = out_5_10;
      out_Jf_x(10, 10) = out_10_10;
      out_Jf_x(11, 10) = out_11_10;
      out_Jf_x(12, 10) = out_12_10;
      out_Jf_x(13, 10) = out_13_10;
      out_Jf_x(6, 11) = out_6_11;
      out_Jf_x(10, 11) = out_10_11;
      out_Jf_x(11, 11) = out_11_11;
      out_Jf_x(12, 11) = out_12_11;
      out_Jf_x(13, 11) = out_13_11;
      out_Jf_x(7, 12) = out_7_12;
      out_Jf_x(11, 12) = out_11_12;
      out_Jf_x(12, 12) = out_12_12;
      out_Jf_x(13, 12) = out_13_12;
      out_Jf_x(6, 13) = out_6_13;
      out_Jf_x(8, 13) = out_8_13;
      out_Jf_x(10, 13) = out_10_13;
      out_Jf_x(11, 13) = out_11_13;
      out_Jf_x(12, 13) = out_12_13;
      out_Jf_x(13, 13) = out_13_13;
    end % Jf_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jf_v = Jf_v( this, in_1, in_2, t )
      % Evaluate the Jacobian of f with respect to v.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      % No body

      % Store outputs
      out_Jf_v = zeros(14, 0);
    end % Jf_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( this, in_1, t )
      % Evaluate the the veils v.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      % No body

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( this, in_1, in_2, t )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      % No body

      % Store outputs
      out_Jv_x = zeros(0, 14);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, in_2, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      t1 = sin(theta);
      t2 = l * t1;
      t4 = cos(theta);
      t5 = l * t4;
      out_1 = lambda__1 * t2 + lambda__3 * t2 - lambda__2 * t5;
      out_2 = -x__1 + t5;
      out_3 = -y__1 + t2;
      out_4 = -x__2 + x__1 + t5;
      out_5 = -y__2;
      t8 = omega * t2;
      out_6 = u__1 + t8;
      out_7 = -omega * t5 + v__1;
      out_8 = u__2 - u__1 + t8;
      out_9 = v__2;
      t10 = t4 ^ 2;
      t11 = omega ^ 2;
      t15 = t1 ^ 2;
      t27 = 0.1e1 / m;
      out_10 = -t27 / t1 * (l * m * t11 * t10 + m * t11 * l * t15 - m * g * t1 + t1 * lambda__2 + t4 * lambda__1 - t4 * lambda__3);
      out_11 = t27 * (2 * lambda__1 - 3 * lambda__3);
      out_12 = -g * m + lambda__4;

      % Store outputs
      out_h = zeros(12, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
      out_h(3) = out_3;
      out_h(4) = out_4;
      out_h(5) = out_5;
      out_h(6) = out_6;
      out_h(7) = out_7;
      out_h(8) = out_8;
      out_h(9) = out_9;
      out_h(10) = out_10;
      out_h(11) = out_11;
      out_h(12) = out_12;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      out_2_1 = -1;
      out_4_1 = 1;
      out_3_2 = -1;
      out_4_3 = -1;
      out_5_4 = -1;
      t1 = cos(theta);
      t2 = t1 * lambda__1;
      t4 = t1 * lambda__3;
      t6 = sin(theta);
      t7 = t6 * lambda__2;
      out_1_5 = l * t2 + l * t4 + l * t7;
      t9 = l * t6;
      out_2_5 = -t9;
      out_3_5 = l * t1;
      out_4_5 = out_2_5;
      out_6_5 = omega * l * t1;
      out_7_5 = omega * t9;
      out_8_5 = out_6_5;
      t17 = 0.1e1 / t6;
      t19 = 0.1e1 / m;
      t21 = t1 ^ 2;
      t22 = omega ^ 2;
      t24 = l * m;
      t26 = t6 ^ 2;
      t27 = l * t26;
      out_10_5 = -t19 * t17 * (-m * g * t1 + t1 * lambda__2 - t6 * lambda__1 + t6 * lambda__3) + t1 * t19 / t26 * (-m * g * t6 + m * t22 * t27 + t24 * t22 * t21 + t2 - t4 + t7);
      out_6_6 = 1;
      out_8_6 = -1;
      out_7_7 = 1;
      out_8_8 = 1;
      out_9_9 = 1;
      out_6_10 = t9;
      out_7_10 = -out_3_5;
      out_8_10 = out_6_10;
      out_10_10 = -t19 * t17 * (2 * omega * m * t27 + 2 * t24 * omega * t21);
      out_1_11 = out_8_10;
      t46 = t19 * t17 * t1;
      out_10_11 = -t46;
      out_11_11 = 2 * t19;
      out_1_12 = out_7_10;
      out_10_12 = -t19;
      out_1_13 = out_1_11;
      out_10_13 = t46;
      out_11_13 = -3 * t19;
      out_12_14 = 1;

      % Store outputs
      out_Jh_x = zeros(12, 14);
      out_Jh_x(2, 1) = out_2_1;
      out_Jh_x(4, 1) = out_4_1;
      out_Jh_x(3, 2) = out_3_2;
      out_Jh_x(4, 3) = out_4_3;
      out_Jh_x(5, 4) = out_5_4;
      out_Jh_x(1, 5) = out_1_5;
      out_Jh_x(2, 5) = out_2_5;
      out_Jh_x(3, 5) = out_3_5;
      out_Jh_x(4, 5) = out_4_5;
      out_Jh_x(6, 5) = out_6_5;
      out_Jh_x(7, 5) = out_7_5;
      out_Jh_x(8, 5) = out_8_5;
      out_Jh_x(10, 5) = out_10_5;
      out_Jh_x(6, 6) = out_6_6;
      out_Jh_x(8, 6) = out_8_6;
      out_Jh_x(7, 7) = out_7_7;
      out_Jh_x(8, 8) = out_8_8;
      out_Jh_x(9, 9) = out_9_9;
      out_Jh_x(6, 10) = out_6_10;
      out_Jh_x(7, 10) = out_7_10;
      out_Jh_x(8, 10) = out_8_10;
      out_Jh_x(10, 10) = out_10_10;
      out_Jh_x(1, 11) = out_1_11;
      out_Jh_x(10, 11) = out_10_11;
      out_Jh_x(11, 11) = out_11_11;
      out_Jh_x(1, 12) = out_1_12;
      out_Jh_x(10, 12) = out_10_12;
      out_Jh_x(1, 13) = out_1_13;
      out_Jh_x(10, 13) = out_10_13;
      out_Jh_x(11, 13) = out_11_13;
      out_Jh_x(12, 14) = out_12_14;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      theta = in_1(5);
      u__1 = in_1(6);
      v__1 = in_1(7);
      u__2 = in_1(8);
      v__2 = in_1(9);
      omega = in_1(10);
      lambda__1 = in_1(11);
      lambda__2 = in_1(12);
      lambda__3 = in_1(13);
      lambda__4 = in_1(14);

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(12, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % CrankRod

% That's All Folks!
