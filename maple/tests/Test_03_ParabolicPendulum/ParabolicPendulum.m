% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: ParabolicPendulum
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef ParabolicPendulum < Indigo.Systems.Implicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_g = 9.81;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = ParabolicPendulum( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 5;
      num_veil = 0;
      num_invs = 3;
      this = this@Indigo.Systems.Implicit('ParabolicPendulum', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_g = varargin{1}.g;
      elseif (nargin == 1)
        this.m_g = varargin{1};
      else
        error('wrong number of input arguments.');
      end
    end % ParabolicPendulum
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_F = F( this, in_1, in_2, in_3, t )
      % Evaluate the function F.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);
      x_dot = in_2(1);
      y_dot = in_2(2);
      u_dot = in_2(3);
      v_dot = in_2(4);
      lambda_dot = in_2(5);

      % Evaluate function
      out_1 = x_dot - u;
      out_2 = y_dot - v;
      t1 = x ^ 2;
      t2 = t1 * x;
      t3 = t2 * lambda;
      t5 = lambda * x;
      t8 = u ^ 2;
      out_3 = -8 * y * t5 - 8 * x * t8 + 8 * t3 + 2 * t5 + u_dot;
      t14 = t1 * lambda;
      t16 = lambda * y;
      t18 = t1 ^ 2;
      t19 = t18 * lambda;
      t21 = t1 * t8;
      out_4 = v_dot + 2 * t8 + g / 2 - 6 * t14 + 2 * t16 - 16 * t19 + 16 * t21 + 16 * t1 * t16;
      t30 = y ^ 2;
      t43 = t18 * x;
      t44 = t43 * lambda;
      t45 = u * y;
      t48 = t8 * u;
      t53 = t30 * u;
      t56 = t48 * t2;
      t66 = lambda_dot * (64 * t18 * t1 + 64 * t1 * t30 - 40 * t1 * y - 128 * t18 * y + 4 * t1 + 36 * t18 + 4 * t30) + 1024 * u * t18 * t2 * lambda - 2048 * t45 * t44 - 1024 * t48 * t43 + 1280 * u * t44 + 1024 * t53 * t3 + 1024 * y * t56 - 256 * v * t19 - 1536 * t45 * t3 - 896 * t56 + 352 * u * t3;
      t72 = t48 * x;
      t93 = -6 * x * u * g + 256 * y * v * t14 + 3 * v * g - 80 * v * t14 + 16 * v * t16 + 192 * v * t21 - 160 * t45 * t5 + 256 * t53 * t5 + 16 * u * t5 + 256 * y * t72 + 24 * v * t8 - 112 * t72;
      out_5 = t66 + t93;

      % Store outputs
      out_F = zeros(5, 1);
      out_F(1) = out_1;
      out_F(2) = out_2;
      out_F(3) = out_3;
      out_F(4) = out_4;
      out_F(5) = out_5;
    end % F
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x = JF_x( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);
      x_dot = in_2(1);
      y_dot = in_2(2);
      u_dot = in_2(3);
      v_dot = in_2(4);
      lambda_dot = in_2(5);

      % Evaluate function
      t1 = x ^ 2;
      t2 = t1 * lambda;
      t4 = lambda * y;
      t6 = u ^ 2;
      t8 = 2 * lambda;
      out_3_1 = 24 * t2 - 8 * t4 - 8 * t6 + t8;
      t9 = t1 * x;
      t10 = t9 * lambda;
      t12 = lambda * x;
      t13 = y * t12;
      t15 = x * t6;
      out_4_1 = -64 * t10 + 32 * t13 + 32 * t15 - 12 * t12;
      t18 = t1 ^ 2;
      t19 = t18 * x;
      t24 = y ^ 2;
      t27 = y * x;
      t36 = t18 * lambda;
      t37 = u * y;
      t40 = t6 * u;
      t48 = t40 * t1;
      t58 = v * y;
      t61 = lambda * u;
      out_5_1 = lambda_dot * (128 * x * t24 - 512 * t9 * y + 384 * t19 - 80 * t27 + 144 * t9 + 8 * x) + 7168 * u * t18 * t1 * lambda - 10240 * t37 * t36 - 5120 * t40 * t18 + 6400 * u * t36 + 3072 * t24 * u * t2 + 3072 * y * t48 - 1024 * v * t10 - 4608 * t37 * t2 - 2688 * t48 + 1056 * u * t2 + 512 * t58 * t12 + 256 * t24 * t61 + 384 * v * t15 + 256 * y * t40 - 160 * v * t12 - 160 * y * t61 - 112 * t40 + 16 * t61 - 6 * u * g;
      out_3_2 = -8 * t12;
      out_4_2 = 16 * t2 + t8;
      t79 = t1 * y;
      t85 = t19 * lambda;
      out_5_2 = lambda_dot * (-128 * t18 + 128 * t79 - 40 * t1 + 8 * y) - 2048 * u * t85 + 2048 * t37 * t10 + 1024 * t40 * t9 - 1536 * u * t10 + 256 * v * t2 + 512 * t37 * t12 + 256 * t40 * x - 160 * u * t12 + 16 * lambda * v;
      out_1_3 = -1;
      t104 = u * x;
      t105 = 16 * t104;
      out_3_3 = -t105;
      t106 = t1 * u;
      out_4_3 = 32 * t106 + 4 * u;
      t109 = t18 * t9;
      t119 = t6 * t9;
      out_5_3 = 256 * x * t24 * lambda + 768 * x * y * t6 - 6 * g * x + 1024 * t109 * lambda + 1024 * t24 * t10 + 384 * v * t106 + 3072 * y * t119 - 3072 * t6 * t19 - 1536 * t9 * t4 - 2048 * y * t85 + 48 * v * u + 352 * t10 - 2688 * t119 + 16 * t12 - 160 * t13 - 336 * t15 + 1280 * t85;
      out_2_4 = -1;
      out_5_4 = 256 * t1 * t4 + 192 * t1 * t6 + 3 * g - 80 * t2 - 256 * t36 + 16 * t4 + 24 * t6;
      out_3_5 = 8 * t9 - 8 * t27 + 2 * x;
      out_4_5 = -16 * t18 + 16 * t79 - 6 * t1 + 2 * y;
      t159 = u * t19;
      t163 = u * t9;
      out_5_5 = -80 * t1 * v + 256 * t24 * t104 + 1024 * u * t109 - 2048 * y * t159 + 1024 * t24 * t163 - 1536 * y * t163 - 256 * v * t18 - 160 * x * t37 + 256 * v * t79 + t105 + 1280 * t159 + 352 * t163 + 16 * t58;

      % Store outputs
      out_JF_x = zeros(5, 5);
      out_JF_x(3, 1) = out_3_1;
      out_JF_x(4, 1) = out_4_1;
      out_JF_x(5, 1) = out_5_1;
      out_JF_x(3, 2) = out_3_2;
      out_JF_x(4, 2) = out_4_2;
      out_JF_x(5, 2) = out_5_2;
      out_JF_x(1, 3) = out_1_3;
      out_JF_x(3, 3) = out_3_3;
      out_JF_x(4, 3) = out_4_3;
      out_JF_x(5, 3) = out_5_3;
      out_JF_x(2, 4) = out_2_4;
      out_JF_x(5, 4) = out_5_4;
      out_JF_x(3, 5) = out_3_5;
      out_JF_x(4, 5) = out_4_5;
      out_JF_x(5, 5) = out_5_5;
    end % JF_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x_dot = JF_x_dot( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x_dot.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);
      x_dot = in_2(1);
      y_dot = in_2(2);
      u_dot = in_2(3);
      v_dot = in_2(4);
      lambda_dot = in_2(5);

      % Evaluate function
      out_1_1 = 1;
      out_2_2 = 1;
      out_3_3 = 1;
      out_4_4 = 1;
      t1 = x ^ 2;
      t2 = t1 ^ 2;
      t8 = y ^ 2;
      out_5_5 = 64 * t2 * t1 + 64 * t8 * t1 - 40 * y * t1 - 128 * y * t2 + 4 * t1 + 36 * t2 + 4 * t8;

      % Store outputs
      out_JF_x_dot = zeros(5, 5);
      out_JF_x_dot(1, 1) = out_1_1;
      out_JF_x_dot(2, 2) = out_2_2;
      out_JF_x_dot(3, 3) = out_3_3;
      out_JF_x_dot(4, 4) = out_4_4;
      out_JF_x_dot(5, 5) = out_5_5;
    end % JF_x_dot
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_v = JF_v( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to v.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);
      x_dot = in_2(1);
      y_dot = in_2(2);
      u_dot = in_2(3);
      v_dot = in_2(4);
      lambda_dot = in_2(5);

      % Evaluate function
      % No elements

      % Store outputs
      out_JF_v = zeros(5, 0);
    end % JF_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( this, in_1, t )
      % Evaluate the the veils v.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);

      % Evaluate function
      % No elements

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( this, in_1, t )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);

      % Evaluate function
      % No elements

      % Store outputs
      out_Jv_x = zeros(0, 5);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, in_2, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);

      % Evaluate function
      t1 = x ^ 2;
      t2 = t1 ^ 2;
      t5 = y ^ 2;
      out_1 = 2 * y * t1 - t1 - t2 - t5 + 1;
      t9 = u * x;
      out_2 = 4 * t1 * x * u - 2 * t1 * v - 4 * y * t9 + 2 * v * y + 2 * t9;
      t20 = t2 * lambda;
      t23 = u ^ 2;
      t27 = t1 * lambda;
      t30 = t1 * t23;
      t48 = v ^ 2;
      out_3 = 64 * t2 * t1 * lambda - 40 * t1 * y * lambda + 8 * u * v * x - t1 * g + g * y + 4 * t5 * lambda - 64 * t2 * t23 - 128 * y * t20 + 8 * y * t23 + 64 * t5 * t27 + 64 * y * t30 + 36 * t20 - 2 * t23 + 4 * t27 - 32 * t30 - 2 * t48;

      % Store outputs
      out_h = zeros(3, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
      out_h(3) = out_3;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);

      % Evaluate function
      t1 = x ^ 2;
      t2 = t1 * x;
      out_1_1 = 4 * x * y - 4 * t2 - 2 * x;
      t7 = t1 * u;
      t9 = u * y;
      t11 = v * x;
      out_2_1 = 12 * t7 - 4 * t9 - 4 * t11 + 2 * u;
      t14 = t1 ^ 2;
      t18 = t2 * lambda;
      t21 = u ^ 2;
      t25 = lambda * x;
      t26 = y ^ 2;
      t29 = x * t21;
      out_3_1 = 384 * t14 * x * lambda - 2 * g * x - 512 * y * t18 - 256 * t2 * t21 + 128 * t26 * t25 - 80 * y * t25 + 128 * y * t29 + 8 * u * v + 144 * t18 + 8 * t25 - 64 * t29;
      out_1_2 = 2 * t1 - 2 * y;
      t41 = u * x;
      out_2_2 = -4 * t41 + 2 * v;
      t46 = lambda * y;
      out_3_2 = -40 * t1 * lambda - 128 * t14 * lambda + 64 * t1 * t21 + 128 * t1 * t46 + g + 8 * t21 + 8 * t46;
      out_2_3 = -out_1_1;
      out_3_3 = -128 * t14 * u + 128 * y * t7 + 8 * t11 - 64 * t7 + 16 * t9 - 4 * u;
      out_2_4 = -out_1_2;
      out_3_4 = 8 * t41 - 4 * v;
      out_3_5 = 64 * t14 * t1 + 64 * t26 * t1 - 40 * y * t1 - 128 * y * t14 + 4 * t1 + 36 * t14 + 4 * t26;

      % Store outputs
      out_Jh_x = zeros(3, 5);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(2, 1) = out_2_1;
      out_Jh_x(3, 1) = out_3_1;
      out_Jh_x(1, 2) = out_1_2;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(3, 2) = out_3_2;
      out_Jh_x(2, 3) = out_2_3;
      out_Jh_x(3, 3) = out_3_3;
      out_Jh_x(2, 4) = out_2_4;
      out_Jh_x(3, 4) = out_3_4;
      out_Jh_x(3, 5) = out_3_5;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x = in_1(1);
      y = in_1(2);
      u = in_1(3);
      v = in_1(4);
      lambda = in_1(5);

      % Evaluate function
      % No elements

      % Store outputs
      out_Jh_v = zeros(3, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % ParabolicPendulum

% That's All Folks!
