% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: FourBar
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef FourBar < Indigo.Systems.Implicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_m = 1.0;
    m_g = 9.81;
    m_l = 1.0;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = FourBar( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 8;
      num_veil = 0;
      num_invs = 2;
      this = this@Indigo.Systems.Implicit('FourBar', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_m = varargin{1}.m;
        this.m_g = varargin{1}.g;
        this.m_l = varargin{1}.l;
      elseif (nargin == 3)
        this.m_m = varargin{1};
        this.m_g = varargin{2};
        this.m_l = varargin{3};
      else
        error('wrong number of input arguments.');
      end
    end % FourBar
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_F = F( this, in_1, in_2, in_3, t )
      % Evaluate the function F.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      theta__0_dot = in_2(1);
      theta__1_dot = in_2(2);
      theta__2_dot = in_2(3);
      omega__0_dot = in_2(4);
      omega__1_dot = in_2(5);
      omega__2_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      out_1 = -omega__0 + theta__0_dot;
      out_2 = -omega__1 + theta__1_dot;
      out_3 = -omega__2 + theta__2_dot;
      t3 = sin(theta__2);
      t6 = cos(theta__2);
      t10 = 0.1e1 / l;
      t12 = 0.1e1 / m;
      out_4 = t12 * t10 * (omega__2_dot * l * m + 3 * t3 * lambda__1 - 3 * t6 * lambda__2);
      t13 = l * m;
      t14 = cos(theta__0);
      t15 = cos(theta__1);
      t16 = t15 * t14;
      t17 = sin(theta__1);
      t18 = sin(theta__0);
      t19 = t18 * t17;
      t28 = omega__1 ^ 2;
      t29 = t28 * m;
      t30 = t29 * l * t17;
      t32 = g * m;
      out_5 = t12 * t10 * (3 * omega__1_dot * (t16 + t19) * t13 + 7 * omega__0_dot * l * m + t14 * (-3 * t30 + 6 * t32 - 3 * lambda__2) + 3 * (t29 * l * t15 + lambda__1) * t18);
      t44 = t15 ^ 2;
      t45 = t44 - 0.1e1 / 0.2e1;
      t46 = t14 ^ 2;
      t48 = t19 * t16;
      t55 = 18 * t32;
      t56 = 9 * lambda__2;
      t59 = t17 * lambda__1;
      t63 = t18 * t44;
      t72 = omega__0 ^ 2;
      t77 = l * t18;
      out_6 = t12 * t10 * (-18 * omega__1_dot * (t46 * t45 + t48 - t44 / 2 - 0.19e2 / 0.18e2) * t13 + t46 * (t15 * (18 * t30 - t55 + t56) + 9 * t59) + t14 * (-18 * t28 * t13 * t63 - 9 * lambda__1 * t18 * t15 + t17 * (t18 * (-t55 + t56) + 21 * t72 * t13) + 9 * t29 * t77) + t15 * (-21 * t72 * m * t77 - 9 * t30 + 21 * t32 - 21 * lambda__2) + 12 * t59);
      out_7 = -7 * (t14 + t15 - 1 + t6) * l * (18 * t44 * t46 - 9 * t44 - 9 * t46 + 18 * t48 - 19);
      t106 = t17 + t18 + t3;
      out_8 = -126 * l * (-t17 * t15 * t46 * t14 + t46 * t45 * t106 + t14 * (t18 * t17 * t3 + t17 + t18 - t63) * t15 - (t44 + 0.19e2 / 0.9e1) * t106 / 2);

      % Store outputs
      out_F = zeros(8, 1);
      out_F(1) = out_1;
      out_F(2) = out_2;
      out_F(3) = out_3;
      out_F(4) = out_4;
      out_F(5) = out_5;
      out_F(6) = out_6;
      out_F(7) = out_7;
      out_F(8) = out_8;
    end % F
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x = JF_x( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      theta__0_dot = in_2(1);
      theta__1_dot = in_2(2);
      theta__2_dot = in_2(3);
      omega__0_dot = in_2(4);
      omega__1_dot = in_2(5);
      omega__2_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      t1 = l * m;
      t2 = sin(theta__0);
      t3 = cos(theta__1);
      t4 = t3 * t2;
      t5 = cos(theta__0);
      t6 = sin(theta__1);
      t8 = t6 * t5 - t4;
      t12 = l * t6;
      t13 = omega__1 ^ 2;
      t14 = t13 * m;
      t15 = t14 * t12;
      t17 = g * m;
      t22 = l * t3;
      t28 = 0.1e1 / l;
      t30 = 0.1e1 / m;
      out_5_1 = t30 * t28 * (3 * omega__1_dot * t8 * t1 - t2 * (-3 * t15 + 6 * t17 - 3 * lambda__2) + 3 * (t14 * t22 + lambda__1) * t5);
      t31 = t3 ^ 2;
      t32 = t31 - 0.1e1 / 0.2e1;
      t36 = t2 ^ 2;
      t38 = t6 * t3 * t36;
      t39 = t5 ^ 2;
      t40 = t3 * t39;
      t41 = t6 * t40;
      t47 = 18 * t17;
      t48 = 9 * lambda__2;
      t49 = 18 * t15 - t47 + t48;
      t57 = t5 * t31;
      t58 = t13 * t1;
      t61 = t5 * t3;
      t64 = -t47 + t48;
      t67 = l * t5;
      t72 = t2 * t31;
      t78 = omega__0 ^ 2;
      t81 = 21 * t78 * t1 + t2 * t64;
      t83 = l * t2;
      t88 = t78 * m;
      out_6_1 = t30 * t28 * (-18 * omega__1_dot * (-2 * t2 * t5 * t32 - t38 + t41) * t1 - 2 * t2 * t5 * (t3 * t49 + 9 * t6 * lambda__1) + t5 * (t6 * t5 * t64 + 9 * t14 * t67 - 18 * t58 * t57 - 9 * lambda__1 * t61) - t2 * (9 * t14 * t83 - 9 * lambda__1 * t4 - 18 * t58 * t72 + t6 * t81) - 21 * t3 * t88 * t67);
      t94 = t2 * t57;
      t98 = t2 * t5;
      t102 = cos(theta__2);
      t103 = t5 + t3 - 1 + t102;
      t107 = t2 * t6;
      t113 = l * (18 * t107 * t61 + 18 * t31 * t39 - 9 * t31 - 9 * t39 - 19);
      out_7_1 = -7 * t103 * l * (-36 * t94 - 18 * t38 + 18 * t41 + 18 * t98) + 7 * t2 * t113;
      t118 = t39 * t5;
      t120 = sin(theta__2);
      t121 = t6 + t2 + t120;
      t125 = t6 * t120;
      t131 = t2 * t125 + t2 + t6 - t72;
      t134 = t31 + 0.19e2 / 0.9e1;
      out_8_1 = -126 * l * (3 * t107 * t40 + t32 * t118 - 2 * t98 * t32 * t121 + t5 * (t5 * t125 + t5 - t57) * t3 - t2 * t131 * t3 - t134 * t5 / 2);
      out_5_2 = t30 * t28 * (-3 * omega__1_dot * t8 * t1 - 3 * t5 * t14 * t22 - 3 * t58 * t107);
      t150 = t6 ^ 2;
      t152 = t2 * t150 * t5;
      t153 = t6 * t3;
      t159 = t14 * l * t31;
      t162 = t3 * lambda__1;
      out_6_2 = t30 * t28 * (-18 * omega__1_dot * (-2 * t41 - t152 + t94 + t153) * t1 + t39 * (-t6 * t49 + 18 * t159 + 9 * t162) + t5 * (36 * t6 * t14 * l * t4 + 9 * lambda__1 * t107 + t3 * t81) - 9 * t159 - t6 * (-21 * t88 * t83 - 9 * t15 + 21 * t17 - 21 * lambda__2) + 12 * t162);
      out_7_2 = -7 * t103 * l * (-36 * t41 - 18 * t152 + 18 * t94 + 18 * t153) + 7 * t6 * t113;
      t199 = t3 * t121;
      t200 = t6 * t39;
      out_8_2 = -126 * l * (t150 * t118 - t31 * t118 + t39 * t32 * t3 - 2 * t200 * t199 - t5 * t131 * t6 + t5 * (t2 * t3 * t120 + 2 * t6 * t4 + t3) * t3 - t134 * t3 / 2 + t6 * t199);
      out_4_3 = t30 * t28 * (3 * t102 * lambda__1 + 3 * t120 * lambda__2);
      out_7_3 = 7 * t120 * t113;
      t227 = t5 * t107;
      out_8_3 = -126 * l * (t39 * t32 * t102 + t227 * t102 * t3 - t134 * t102 / 2);
      out_1_4 = -1;
      out_6_4 = t30 * t28 * (-42 * t3 * omega__0 * m * t83 + 42 * t5 * t6 * omega__0 * t1);
      out_2_5 = -1;
      t243 = omega__1 * m;
      t246 = omega__1 * t1;
      out_5_5 = t30 * t28 * (-6 * t5 * t243 * t12 + 6 * t246 * t4);
      out_6_5 = t30 * t28 * (36 * t39 * t3 * omega__1 * m * t12 + t5 * (18 * t243 * t83 - 36 * t246 * t72) - 18 * t3 * t243 * t12);
      out_3_6 = -1;
      out_4_7 = 3 * t30 * t28 * t120;
      out_5_7 = 3 * t30 * t28 * t2;
      out_6_7 = t30 * t28 * (-9 * t2 * t61 + 9 * t200 + 12 * t6);
      out_4_8 = -3 * t30 * t28 * t102;
      out_5_8 = -3 * t30 * t28 * t5;
      out_6_8 = t30 * t28 * (9 * t40 + 9 * t227 - 21 * t3);

      % Store outputs
      out_JF_x = zeros(8, 8);
      out_JF_x(5, 1) = out_5_1;
      out_JF_x(6, 1) = out_6_1;
      out_JF_x(7, 1) = out_7_1;
      out_JF_x(8, 1) = out_8_1;
      out_JF_x(5, 2) = out_5_2;
      out_JF_x(6, 2) = out_6_2;
      out_JF_x(7, 2) = out_7_2;
      out_JF_x(8, 2) = out_8_2;
      out_JF_x(4, 3) = out_4_3;
      out_JF_x(7, 3) = out_7_3;
      out_JF_x(8, 3) = out_8_3;
      out_JF_x(1, 4) = out_1_4;
      out_JF_x(6, 4) = out_6_4;
      out_JF_x(2, 5) = out_2_5;
      out_JF_x(5, 5) = out_5_5;
      out_JF_x(6, 5) = out_6_5;
      out_JF_x(3, 6) = out_3_6;
      out_JF_x(4, 7) = out_4_7;
      out_JF_x(5, 7) = out_5_7;
      out_JF_x(6, 7) = out_6_7;
      out_JF_x(4, 8) = out_4_8;
      out_JF_x(5, 8) = out_5_8;
      out_JF_x(6, 8) = out_6_8;
    end % JF_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x_dot = JF_x_dot( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x_dot.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      theta__0_dot = in_2(1);
      theta__1_dot = in_2(2);
      theta__2_dot = in_2(3);
      omega__0_dot = in_2(4);
      omega__1_dot = in_2(5);
      omega__2_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      out_1_1 = 1;
      out_2_2 = 1;
      out_3_3 = 1;
      out_5_4 = 7;
      t1 = cos(theta__0);
      t2 = cos(theta__1);
      t3 = t2 * t1;
      t4 = sin(theta__1);
      t5 = sin(theta__0);
      t6 = t5 * t4;
      out_5_5 = 3 * t3 + 3 * t6;
      t8 = t2 ^ 2;
      t10 = t1 ^ 2;
      out_6_5 = -18 * t10 * (t8 - 0.1e1 / 0.2e1) - 18 * t6 * t3 + 9 * t8 + 19;
      out_4_6 = 1;

      % Store outputs
      out_JF_x_dot = zeros(8, 8);
      out_JF_x_dot(1, 1) = out_1_1;
      out_JF_x_dot(2, 2) = out_2_2;
      out_JF_x_dot(3, 3) = out_3_3;
      out_JF_x_dot(5, 4) = out_5_4;
      out_JF_x_dot(5, 5) = out_5_5;
      out_JF_x_dot(6, 5) = out_6_5;
      out_JF_x_dot(4, 6) = out_4_6;
    end % JF_x_dot
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_v = JF_v( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to v.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);
      theta__0_dot = in_2(1);
      theta__1_dot = in_2(2);
      theta__2_dot = in_2(3);
      omega__0_dot = in_2(4);
      omega__1_dot = in_2(5);
      omega__2_dot = in_2(6);
      lambda__1_dot = in_2(7);
      lambda__2_dot = in_2(8);

      % Evaluate function
      % No body

      % Store outputs
      out_JF_v = zeros(8, 0);
    end % JF_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( this, in_1, t )
      % Evaluate the the veils v.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( this, in_1, in_2, t )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_Jv_x = zeros(0, 8);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, in_2, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      t1 = cos(theta__0);
      t2 = t1 ^ 2;
      t3 = cos(theta__1);
      t4 = t3 ^ 2;
      t8 = sin(theta__1);
      t9 = sin(theta__0);
      t17 = cos(theta__2);
      out_1 = -7 * (t1 + t3 - 1 + t17) * l * (18 * t9 * t8 * t3 * t1 + 18 * t4 * t2 - 9 * t2 - 9 * t4 - 19);
      t24 = sin(theta__2);
      t25 = t8 + t9 + t24;
      out_2 = -126 * l * (-t8 * t3 * t2 * t1 + t2 * (t4 - 0.1e1 / 0.2e1) * t25 + t1 * (t9 * t8 * t24 - t9 * t4 + t8 + t9) * t3 - (t4 + 0.19e2 / 0.9e1) * t25 / 2);

      % Store outputs
      out_h = zeros(2, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      t1 = cos(theta__0);
      t2 = cos(theta__1);
      t3 = t2 ^ 2;
      t4 = t3 * t1;
      t5 = sin(theta__0);
      t6 = t5 * t4;
      t8 = t5 ^ 2;
      t10 = sin(theta__1);
      t13 = t1 ^ 2;
      t14 = t2 * t13;
      t15 = t10 * t14;
      t17 = t5 * t1;
      t21 = cos(theta__2);
      t22 = t1 + t2 - 1 + t21;
      t27 = t5 * t10;
      t33 = l * (18 * t27 * t2 * t1 + 18 * t3 * t13 - 9 * t13 - 9 * t3 - 19);
      out_1_1 = -7 * t22 * l * (-18 * t10 * t2 * t8 + 18 * t15 + 18 * t17 - 36 * t6) + 7 * t5 * t33;
      t38 = t13 * t1;
      t39 = t3 - 0.1e1 / 0.2e1;
      t41 = sin(theta__2);
      t42 = t10 + t5 + t41;
      t46 = t10 * t41;
      t53 = -t5 * t3 + t5 * t46 + t10 + t5;
      t56 = t3 + 0.19e2 / 0.9e1;
      out_2_1 = -126 * l * (3 * t27 * t14 + t39 * t38 - 2 * t17 * t39 * t42 + t1 * (t1 * t46 + t1 - t4) * t2 - t5 * t53 * t2 - t56 * t1 / 2);
      t63 = t10 ^ 2;
      out_1_2 = -7 * t22 * l * (-18 * t5 * t63 * t1 + 18 * t10 * t2 - 36 * t15 + 18 * t6) + 7 * t10 * t33;
      t79 = t2 * t42;
      out_2_2 = -126 * l * (t63 * t38 - t3 * t38 + t13 * t39 * t2 - 2 * t13 * t10 * t79 - t1 * t53 * t10 + t1 * (2 * t10 * t5 * t2 + t5 * t2 * t41 + t2) * t2 - t56 * t2 / 2 + t10 * t79);
      out_1_3 = 7 * t41 * t33;
      out_2_3 = -126 * l * (t13 * t39 * t21 + t1 * t27 * t21 * t2 - t56 * t21 / 2);

      % Store outputs
      out_Jh_x = zeros(2, 8);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(2, 1) = out_2_1;
      out_Jh_x(1, 2) = out_1_2;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(1, 3) = out_1_3;
      out_Jh_x(2, 3) = out_2_3;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      m = this.m_m;
      g = this.m_g;
      l = this.m_l;

      % Extract inputs
      theta__0 = in_1(1);
      theta__1 = in_1(2);
      theta__2 = in_1(3);
      omega__0 = in_1(4);
      omega__1 = in_1(5);
      omega__2 = in_1(6);
      lambda__1 = in_1(7);
      lambda__2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(2, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % FourBar

% That's All Folks!
