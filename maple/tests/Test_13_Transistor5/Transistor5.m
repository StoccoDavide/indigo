% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: Transistor5
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef Transistor5 < Indigo.DAE.Implicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_U__b = 6.0;
    m_U__f = .26e-1;
    m_alpha = .99;
    m_beta = .1e-5;
    m_R__0 = .1e4;
    m_R__1 = .9e4;
    m_R__2 = .9e4;
    m_R__3 = .9e4;
    m_R__4 = .9e4;
    m_R__5 = .9e4;
    m_R__6 = .9e4;
    m_C__1 = .1e-5;
    m_C__2 = .2e-5;
    m_C__3 = .3e-5;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = Transistor5( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 5;
      num_veil = 0;
      num_invs = 2;
      this = this@Indigo.DAE.Implicit('Transistor5', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_U__b = varargin{1}.U__b;
        this.m_U__f = varargin{1}.U__f;
        this.m_alpha = varargin{1}.alpha;
        this.m_beta = varargin{1}.beta;
        this.m_R__0 = varargin{1}.R__0;
        this.m_R__1 = varargin{1}.R__1;
        this.m_R__2 = varargin{1}.R__2;
        this.m_R__3 = varargin{1}.R__3;
        this.m_R__4 = varargin{1}.R__4;
        this.m_R__5 = varargin{1}.R__5;
        this.m_R__6 = varargin{1}.R__6;
        this.m_C__1 = varargin{1}.C__1;
        this.m_C__2 = varargin{1}.C__2;
        this.m_C__3 = varargin{1}.C__3;
      elseif (nargin == 14)
        this.m_U__b = varargin{1};
        this.m_U__f = varargin{2};
        this.m_alpha = varargin{3};
        this.m_beta = varargin{4};
        this.m_R__0 = varargin{5};
        this.m_R__1 = varargin{6};
        this.m_R__2 = varargin{7};
        this.m_R__3 = varargin{8};
        this.m_R__4 = varargin{9};
        this.m_R__5 = varargin{10};
        this.m_R__6 = varargin{11};
        this.m_C__1 = varargin{12};
        this.m_C__2 = varargin{13};
        this.m_C__3 = varargin{14};
      else
        error('wrong number of input arguments.');
      end
    end % Transistor5
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_F = F( this, in_1, in_2, ~, t )
      % Evaluate the function F.

      % Extract properties
      U__b = this.m_U__b;
      U__f = this.m_U__f;
      alpha = this.m_alpha;
      beta = this.m_beta;
      R__0 = this.m_R__0;
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__3 = this.m_R__3;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;
      C__1 = this.m_C__1;
      C__2 = this.m_C__2;
      C__3 = this.m_C__3;

      % Extract inputs
      y__2 = in_1(2);
      y__3 = in_1(3);
      y__4 = in_1(4);
      y__1_dot = in_2(1);
      y__2_dot = in_2(2);
      y__3_dot = in_2(3);
      y__4_dot = in_2(4);
      y__5_dot = in_2(5);

      % Evaluate function
      t3 = beta * R__3;
      t4 = y__2 - y__3;
      t5 = 0.1e1 / U__f;
      t7 = exp(t5 * t4);
      t10 = 0.1e1 / R__3;
      out_1 = t10 * (-C__2 * y__3_dot * R__3 + t7 * t3 - t3 - y__3);
      t12 = alpha - 1;
      t17 = R__1 * R__2;
      t21 = -R__1 - R__2;
      t28 = 0.1e1 / R__1;
      t30 = 0.1e1 / R__2;
      out_2 = t30 * t28 * (t7 * t12 * R__2 * beta * R__1 + t17 * C__1 * y__1_dot - t17 * C__1 * y__2_dot + y__2 * t21 - R__1 * (R__2 * t12 * beta - U__b));
      t31 = alpha * beta;
      t38 = R__4 * t31;
      t40 = 0.1e1 / R__4;
      out_3 = t40 * (-C__3 * y__4_dot * R__4 + C__3 * y__5_dot * R__4 - t7 * R__4 * t31 + U__b + t38 - y__4);
      t43 = exp(2 * t5 * t4);
      t47 = beta ^ 2;
      t59 = C__2 * U__f;
      t75 = 0.1e1 / C__2;
      out_4 = t40 / R__5 / C__3 * t10 * t5 * t75 * (-t47 * alpha * R__4 * R__5 * R__3 * t43 * C__3 + t7 * alpha * R__4 * beta * (C__2 * C__3 * R__3 * R__5 * y__2_dot + y__3 * C__3 * R__5 + (C__3 * R__5 * beta + t59) * R__3) - U__f * R__3 * C__2 * (-C__3 * (R__5 + R__4) * y__4_dot + t38 - y__4 + U__b));
      t83 = alpha - 0.1e1;
      t85 = t47 * C__1;
      t92 = -0.1e1 * alpha + 0.1e1;
      t93 = R__0 * t92;
      t97 = R__3 * R__1;
      t107 = C__2 * beta;
      t117 = cos(200 * pi * t);
      out_5 = t30 * t28 / C__1 * t10 * t5 * t75 / R__0 * (t43 * R__1 * R__2 * R__3 * t85 * R__0 * t83 + t7 * (y__2_dot * t97 * C__2 * R__2 * beta * C__1 * t93 + C__1 * R__2 * R__1 * y__3 * beta * t93 + t97 * R__2 * (t107 * U__f * t92 + t85 * t93)) + 0.2513274123e3 * t17 * R__3 * C__1 * U__f * C__2 * t117 + y__2_dot * t59 * C__1 * ((R__0 + R__2) * R__1 + R__0 * R__2) * R__3 - y__2 * t21 * U__f * C__2 * R__3 + R__1 * R__3 * (R__2 * t107 * U__f * t83 - 0.1e1 * C__2 * U__b * U__f));

      % Store outputs
      out_F = zeros(5, 1);
      out_F(1) = out_1;
      out_F(2) = out_2;
      out_F(3) = out_3;
      out_F(4) = out_4;
      out_F(5) = out_5;
    end % F
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x = JF_x( this, in_1, in_2, ~, ~ )
      % Evaluate the Jacobian of F with respect to x.

      % Extract properties
      U__f = this.m_U__f;
      alpha = this.m_alpha;
      beta = this.m_beta;
      R__0 = this.m_R__0;
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__3 = this.m_R__3;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;
      C__1 = this.m_C__1;
      C__2 = this.m_C__2;
      C__3 = this.m_C__3;

      % Extract inputs
      y__2 = in_1(2);
      y__3 = in_1(3);
      y__2_dot = in_2(2);

      % Evaluate function
      t1 = 0.1e1 / U__f;
      t3 = y__2 - y__3;
      t5 = exp(t1 * t3);
      out_1_2 = t5 * t1 * beta;
      t8 = alpha - 1;
      t13 = 0.1e1 / R__1;
      t15 = 0.1e1 / R__2;
      out_2_2 = t15 * t13 * (t5 * t1 * t8 * beta * R__1 * R__2 - R__1 - R__2);
      t16 = t5 * t1;
      t18 = alpha * beta * t16;
      out_3_2 = -t18;
      t22 = exp(2 * t1 * t3);
      t26 = beta ^ 2;
      t30 = 2 * t26 * alpha * R__4 * R__5 * R__3 * t22 * t1 * C__3;
      t38 = C__3 * R__5 * beta;
      t47 = t5 * t1 * alpha * R__4 * beta * (C__2 * C__3 * R__3 * R__5 * y__2_dot + y__3 * C__3 * R__5 + (C__2 * U__f + t38) * R__3);
      t49 = 0.1e1 / C__2;
      t52 = 0.1e1 / R__3;
      t53 = 0.1e1 / C__3;
      t55 = 0.1e1 / R__5;
      t56 = 0.1e1 / R__4;
      t58 = t56 * t55 * t53 * t52;
      out_4_2 = t58 * t1 * t49 * (-t30 + t47);
      t61 = t26 * C__1;
      t68 = 2 * t22 * t1 * R__1 * R__2 * R__3 * t61 * (alpha - 0.1e1) * R__0;
      t70 = -0.1e1 * alpha + 0.1e1;
      t71 = R__0 * t70;
      t75 = R__3 * R__1;
      t79 = beta * t71;
      t80 = C__1 * R__2;
      t93 = t5 * t1 * (y__2_dot * t75 * C__2 * R__2 * beta * C__1 * t71 + R__1 * y__3 * t80 * t79 + t75 * R__2 * (C__2 * beta * U__f * t70 + t61 * t71));
      t99 = 0.1e1 / R__0;
      t101 = t1 * t49;
      t106 = t15 * t13 / C__1 * t52;
      out_5_2 = t106 * t101 * t99 * (t68 + t93 + C__2 * R__3 * U__f * (R__2 + R__1));
      out_1_3 = t52 * (-t16 * beta * R__3 - 1);
      out_2_3 = -t16 * t8 * beta;
      out_3_3 = t18;
      out_4_3 = t58 * t1 * t49 * (t5 * alpha * R__4 * t38 + t30 - t47);
      out_5_3 = t106 * t101 * t99 * (t5 * R__1 * t80 * t79 - t68 - t93);
      out_3_4 = -t56;
      out_4_4 = t56 * t55 * t53;

      % Store outputs
      out_JF_x = zeros(5, 5);
      out_JF_x(1, 2) = out_1_2;
      out_JF_x(2, 2) = out_2_2;
      out_JF_x(3, 2) = out_3_2;
      out_JF_x(4, 2) = out_4_2;
      out_JF_x(5, 2) = out_5_2;
      out_JF_x(1, 3) = out_1_3;
      out_JF_x(2, 3) = out_2_3;
      out_JF_x(3, 3) = out_3_3;
      out_JF_x(4, 3) = out_4_3;
      out_JF_x(5, 3) = out_5_3;
      out_JF_x(3, 4) = out_3_4;
      out_JF_x(4, 4) = out_4_4;
    end % JF_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x_dot = JF_x_dot( this, in_1, ~, ~, ~ )
      % Evaluate the Jacobian of F with respect to x_dot.

      % Extract properties
      U__f = this.m_U__f;
      alpha = this.m_alpha;
      beta = this.m_beta;
      R__0 = this.m_R__0;
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__3 = this.m_R__3;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;
      C__1 = this.m_C__1;
      C__2 = this.m_C__2;
      C__3 = this.m_C__3;

      % Extract inputs
      y__2 = in_1(2);
      y__3 = in_1(3);

      % Evaluate function
      out_2_1 = C__1;
      out_2_2 = -C__1;
      t1 = 0.1e1 / U__f;
      t4 = exp(t1 * (y__2 - y__3));
      out_4_2 = alpha * beta * t4 * t1;
      out_5_2 = 0.1e1 / R__3 / C__1 / R__1 / R__2 * t1 / C__2 / R__0 * (t4 * R__1 * R__3 * C__2 * R__2 * (-0.1e1 * alpha + 0.1e1) * R__0 * beta * C__1 + C__1 * ((R__0 + R__2) * R__1 + R__0 * R__2) * R__3 * C__2 * U__f);
      out_1_3 = -C__2;
      out_3_4 = -C__3;
      out_4_4 = (R__5 + R__4) / R__5 / R__4;
      out_3_5 = C__3;

      % Store outputs
      out_JF_x_dot = zeros(5, 5);
      out_JF_x_dot(2, 1) = out_2_1;
      out_JF_x_dot(2, 2) = out_2_2;
      out_JF_x_dot(4, 2) = out_4_2;
      out_JF_x_dot(5, 2) = out_5_2;
      out_JF_x_dot(1, 3) = out_1_3;
      out_JF_x_dot(3, 4) = out_3_4;
      out_JF_x_dot(4, 4) = out_4_4;
      out_JF_x_dot(3, 5) = out_3_5;
    end % JF_x_dot
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_v = JF_v( ~, ~, ~, ~, ~ )
      % Evaluate the Jacobian of F with respect to v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_JF_v = zeros(5, 0);
    end % JF_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( ~, ~, ~ )
      % Evaluate the the veils v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( ~, ~, ~, ~ )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_Jv_x = zeros(0, 5);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, ~, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      U__b = this.m_U__b;
      U__f = this.m_U__f;
      alpha = this.m_alpha;
      beta = this.m_beta;
      R__0 = this.m_R__0;
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;

      % Extract inputs
      y__1 = in_1(1);
      y__2 = in_1(2);
      y__3 = in_1(3);
      y__4 = in_1(4);
      y__5 = in_1(5);

      % Evaluate function
      t9 = exp((y__2 - y__3) / U__f);
      t14 = sin(200 * pi * t);
      out_1 = 0.1e1 / R__1 / R__2 / R__0 * (t9 * R__1 * R__0 * (-0.1e1 * alpha + 0.1e1) * beta * R__2 + 0.4e0 * R__2 * R__1 * t14 + R__0 * (R__2 + R__1) * y__2 + y__1 * R__1 * R__2 + ((alpha - 0.1e1) * beta * R__2 - 0.1e1 * U__b) * R__0 * R__1);
      out_2 = 0.1e1 / R__5 / R__4 * (R__5 * alpha * beta * R__4 * t9 + y__4 * R__5 + y__5 * R__4 - R__5 * (alpha * beta * R__4 + U__b));

      % Store outputs
      out_h = zeros(2, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, ~, ~ )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      U__f = this.m_U__f;
      alpha = this.m_alpha;
      beta = this.m_beta;
      R__0 = this.m_R__0;
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;

      % Extract inputs
      y__2 = in_1(2);
      y__3 = in_1(3);

      % Evaluate function
      out_1_1 = 0.1e1 / R__0;
      t3 = (-0.1e1 * alpha + 0.1e1) * beta;
      t6 = 0.1e1 / U__f;
      t9 = exp(t6 * (y__2 - y__3));
      t10 = t9 * t6;
      out_1_2 = 0.1e1 / R__1 / R__2 * out_1_1 * (t10 * R__0 * R__1 * R__2 * t3 + R__0 * (R__2 + R__1));
      out_2_2 = alpha * beta * t10;
      out_1_3 = -t10 * t3;
      out_2_3 = -out_2_2;
      out_2_4 = 0.1e1 / R__4;
      out_2_5 = 0.1e1 / R__5;

      % Store outputs
      out_Jh_x = zeros(2, 5);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(1, 2) = out_1_2;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(1, 3) = out_1_3;
      out_Jh_x(2, 3) = out_2_3;
      out_Jh_x(2, 4) = out_2_4;
      out_Jh_x(2, 5) = out_2_5;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_pivots = pivots( this, in_1, ~, ~ )
      % Calculate the pivoting values

      % Extract properties
      U__f = this.m_U__f;
      alpha = this.m_alpha;
      beta = this.m_beta;
      R__0 = this.m_R__0;
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;
      C__1 = this.m_C__1;
      C__2 = this.m_C__2;
      C__3 = this.m_C__3;

      % Extract inputs
      y__2 = in_1(2);
      y__3 = in_1(3);

      % Evaluate function
      out_1_1 = -C__2;
      out_2_1 = C__1;
      out_3_1 = C__3;
      out_4_1 = -1;
      out_5_1 = -1;
      out_1_2 = out_1_1;
      out_2_2 = C__1;
      out_3_2 = C__3;
      out_4_2 = (R__5 + R__4) / R__5 / R__4;
      t11 = 0.1e1 / U__f;
      t13 = exp(t11 * (y__2 - y__3));
      t16 = U__f * R__1;
      out_5_2 = 0.1e1 / R__0 / R__1 / R__2 * t11 * (t13 * R__1 * R__0 * (-0.1e1 * alpha + 0.1e1) * beta * R__2 + R__0 * (0.1e1 * t16 + 0.1e1 * U__f * R__2) + 0.1e1 * R__2 * t16);

      % Store outputs
      out_pivots = zeros(5, 2);
      out_pivots(1, 1) = out_1_1;
      out_pivots(2, 1) = out_2_1;
      out_pivots(3, 1) = out_3_1;
      out_pivots(4, 1) = out_4_1;
      out_pivots(5, 1) = out_5_1;
      out_pivots(1, 2) = out_1_2;
      out_pivots(2, 2) = out_2_2;
      out_pivots(3, 2) = out_3_2;
      out_pivots(4, 2) = out_4_2;
      out_pivots(5, 2) = out_5_2;
    end % pivots
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( ~, ~, ~, ~ )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(2, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out = in_domain( ~, ~, ~ )
      out = true;
    end % in_domain
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % Transistor5

% That's All Folks!
