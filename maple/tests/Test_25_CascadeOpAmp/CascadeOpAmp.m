% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: CascadeOpAmp
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef CascadeOpAmp < Indigo.DAE.Explicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_U_i = 12;
    m_f = 300;
    m_R__1 = .1e7;
    m_R__2 = .1e7;
    m_R__3 = .1e7;
    m_R__4 = .1e7;
    m_R__5 = .1e7;
    m_R__6 = .1e7;
    m_R__7 = .1e7;
    m_R__8 = .1e7;
    m_R__9 = .1e7;
    m_R__10 = .1e7;
    m_C__1 = .1e-5;
    m_C__2 = .1e-5;
    m_C__3 = .1e-5;
    m_C__4 = .1e-5;
    m_C__5 = .1e-5;
    m_C__6 = .1e-5;
    m_C__7 = .1e-5;
    m_C__8 = .1e-5;
    m_C__9 = .1e-5;
    m_C__10 = .1e-5;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = CascadeOpAmp( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 10;
      num_veil = 0;
      num_invs = 10;
      this = this@Indigo.DAE.Explicit('CascadeOpAmp', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_U_i = varargin{1}.U_i;
        this.m_f = varargin{1}.f;
        this.m_R__1 = varargin{1}.R__1;
        this.m_R__2 = varargin{1}.R__2;
        this.m_R__3 = varargin{1}.R__3;
        this.m_R__4 = varargin{1}.R__4;
        this.m_R__5 = varargin{1}.R__5;
        this.m_R__6 = varargin{1}.R__6;
        this.m_R__7 = varargin{1}.R__7;
        this.m_R__8 = varargin{1}.R__8;
        this.m_R__9 = varargin{1}.R__9;
        this.m_R__10 = varargin{1}.R__10;
        this.m_C__1 = varargin{1}.C__1;
        this.m_C__2 = varargin{1}.C__2;
        this.m_C__3 = varargin{1}.C__3;
        this.m_C__4 = varargin{1}.C__4;
        this.m_C__5 = varargin{1}.C__5;
        this.m_C__6 = varargin{1}.C__6;
        this.m_C__7 = varargin{1}.C__7;
        this.m_C__8 = varargin{1}.C__8;
        this.m_C__9 = varargin{1}.C__9;
        this.m_C__10 = varargin{1}.C__10;
      elseif (nargin == 22)
        this.m_U_i = varargin{1};
        this.m_f = varargin{2};
        this.m_R__1 = varargin{3};
        this.m_R__2 = varargin{4};
        this.m_R__3 = varargin{5};
        this.m_R__4 = varargin{6};
        this.m_R__5 = varargin{7};
        this.m_R__6 = varargin{8};
        this.m_R__7 = varargin{9};
        this.m_R__8 = varargin{10};
        this.m_R__9 = varargin{11};
        this.m_R__10 = varargin{12};
        this.m_C__1 = varargin{13};
        this.m_C__2 = varargin{14};
        this.m_C__3 = varargin{15};
        this.m_C__4 = varargin{16};
        this.m_C__5 = varargin{17};
        this.m_C__6 = varargin{18};
        this.m_C__7 = varargin{19};
        this.m_C__8 = varargin{20};
        this.m_C__9 = varargin{21};
        this.m_C__10 = varargin{22};
      else
        error('wrong number of input arguments.');
      end
    end % CascadeOpAmp
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_f = f( this, ~, ~, t )
      % Evaluate the function f.

      % Extract properties
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__3 = this.m_R__3;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;
      R__6 = this.m_R__6;
      R__7 = this.m_R__7;
      R__8 = this.m_R__8;
      R__9 = this.m_R__9;
      R__10 = this.m_R__10;
      C__1 = this.m_C__1;
      C__2 = this.m_C__2;
      C__3 = this.m_C__3;
      C__4 = this.m_C__4;
      C__5 = this.m_C__5;
      C__6 = this.m_C__6;
      C__7 = this.m_C__7;
      C__8 = this.m_C__8;
      C__9 = this.m_C__9;
      C__10 = this.m_C__10;

      % Extract inputs

      % Evaluate function
      t1 = R__1 * C__1;
      t2 = diff(diff(U(t), t), t);
      out_1 = -t2 * t1;
      t4 = C__2 * R__2;
      t5 = diff(diff(diff(U(t), t), t), t);
      out_2 = t5 * t1 * t4;
      t7 = C__3 * R__3;
      t8 = C__2 * t7;
      t9 = R__2 * C__1;
      t10 = diff(diff(diff(diff(U(t), t), t), t), t);
      out_3 = -t10 * R__1 * t9 * t8;
      t14 = C__4 * R__4;
      t15 = t7 * t14;
      t16 = diff(diff(diff(diff(diff(U(t), t), t), t), t), t);
      out_4 = t16 * t1 * t4 * t15;
      t19 = C__5 * R__5;
      t21 = C__3 * t14 * t19;
      t22 = C__2 * R__3;
      t23 = R__2 * t22;
      t24 = diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t);
      out_5 = -t24 * t1 * t23 * t21;
      t28 = C__6 * R__6;
      t29 = C__5 * t28;
      t30 = C__4 * R__5;
      t33 = diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t);
      out_6 = t33 * R__1 * t9 * t8 * R__4 * t30 * t29;
      t37 = C__7 * R__7;
      t42 = R__4 * C__3;
      t44 = diff(diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t), t);
      out_7 = -t44 * R__1 * t9 * t22 * t42 * t30 * R__6 * C__5 * C__6 * t37;
      t49 = C__8 * R__8;
      t53 = diff(diff(diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t), t), t);
      out_8 = t53 * t1 * t4 * t15 * t19 * t28 * t37 * t49;
      t57 = C__9 * R__9;
      t63 = diff(diff(diff(diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t), t), t), t);
      out_9 = -t63 * t1 * t4 * R__3 * t42 * t30 * t29 * t37 * t49 * t57;
      t76 = diff(diff(diff(diff(diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t), t), t), t), t);
      out_10 = t76 * t1 * t23 * t21 * R__8 * C__7 * R__7 * C__6 * R__6 * C__8 * t57 * C__10 * R__10;

      % Store outputs
      out_f = zeros(10, 1);
      out_f(1) = out_1;
      out_f(2) = out_2;
      out_f(3) = out_3;
      out_f(4) = out_4;
      out_f(5) = out_5;
      out_f(6) = out_6;
      out_f(7) = out_7;
      out_f(8) = out_8;
      out_f(9) = out_9;
      out_f(10) = out_10;
    end % f
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jf_x = Jf_x( ~, ~, ~, ~ )
      % Evaluate the Jacobian of f with respect to x.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_Jf_x = zeros(10, 10);
    end % Jf_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jf_v = Jf_v( ~, ~, ~, ~ )
      % Evaluate the Jacobian of f with respect to v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_Jf_v = zeros(10, 0);
    end % Jf_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( ~, ~, ~ )
      % Evaluate the the veils v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( ~, ~, ~, ~ )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_Jv_x = zeros(0, 10);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, ~, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      R__1 = this.m_R__1;
      R__2 = this.m_R__2;
      R__3 = this.m_R__3;
      R__4 = this.m_R__4;
      R__5 = this.m_R__5;
      R__6 = this.m_R__6;
      R__7 = this.m_R__7;
      R__8 = this.m_R__8;
      R__9 = this.m_R__9;
      R__10 = this.m_R__10;
      C__1 = this.m_C__1;
      C__2 = this.m_C__2;
      C__3 = this.m_C__3;
      C__4 = this.m_C__4;
      C__5 = this.m_C__5;
      C__6 = this.m_C__6;
      C__7 = this.m_C__7;
      C__8 = this.m_C__8;
      C__9 = this.m_C__9;
      C__10 = this.m_C__10;

      % Extract inputs
      x__1 = in_1(1);
      x__2 = in_1(2);
      x__3 = in_1(3);
      x__4 = in_1(4);
      x__5 = in_1(5);
      x__6 = in_1(6);
      x__7 = in_1(7);
      x__8 = in_1(8);
      x__9 = in_1(9);
      x__10 = in_1(10);

      % Evaluate function
      t1 = R__1 * C__1;
      t2 = diff(U(t), t);
      out_1 = -t2 * t1 - x__1;
      t4 = C__2 * R__2;
      t5 = diff(diff(U(t), t), t);
      out_2 = t5 * t1 * t4 - x__2;
      t8 = C__3 * R__3;
      t9 = C__2 * t8;
      t10 = R__2 * C__1;
      t11 = diff(diff(diff(U(t), t), t), t);
      out_3 = -t11 * R__1 * t10 * t9 - x__3;
      t15 = C__4 * R__4;
      t16 = t8 * t15;
      t17 = diff(diff(diff(diff(U(t), t), t), t), t);
      out_4 = t17 * t1 * t4 * t16 - x__4;
      t21 = C__5 * R__5;
      t23 = C__3 * t15 * t21;
      t24 = C__2 * R__3;
      t25 = R__2 * t24;
      t26 = diff(diff(diff(diff(diff(U(t), t), t), t), t), t);
      out_5 = -t26 * t1 * t25 * t23 - x__5;
      t30 = C__6 * R__6;
      t31 = C__5 * t30;
      t32 = C__4 * R__5;
      t35 = diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t);
      out_6 = t35 * R__1 * t10 * t9 * R__4 * t32 * t31 - x__6;
      t40 = C__7 * R__7;
      t45 = R__4 * C__3;
      t47 = diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t);
      out_7 = -t47 * R__1 * t10 * t24 * t45 * t32 * R__6 * C__5 * C__6 * t40 - x__7;
      t52 = C__8 * R__8;
      t56 = diff(diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t), t);
      out_8 = t56 * t1 * t4 * t16 * t21 * t30 * t40 * t52 - x__8;
      t61 = C__9 * R__9;
      t67 = diff(diff(diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t), t), t);
      out_9 = -t67 * t1 * t4 * R__3 * t45 * t32 * t31 * t40 * t52 * t61 - x__9;
      t80 = diff(diff(diff(diff(diff(diff(diff(diff(diff(diff(U(t), t), t), t), t), t), t), t), t), t), t);
      out_10 = t80 * t1 * t25 * t23 * R__8 * C__7 * R__7 * C__6 * R__6 * C__8 * t61 * C__10 * R__10 - x__10;

      % Store outputs
      out_h = zeros(10, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
      out_h(3) = out_3;
      out_h(4) = out_4;
      out_h(5) = out_5;
      out_h(6) = out_6;
      out_h(7) = out_7;
      out_h(8) = out_8;
      out_h(9) = out_9;
      out_h(10) = out_10;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( ~, ~, ~, ~ )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      out_1_1 = -1;
      out_2_2 = -1;
      out_3_3 = -1;
      out_4_4 = -1;
      out_5_5 = -1;
      out_6_6 = -1;
      out_7_7 = -1;
      out_8_8 = -1;
      out_9_9 = -1;
      out_10_10 = -1;

      % Store outputs
      out_Jh_x = zeros(10, 10);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(3, 3) = out_3_3;
      out_Jh_x(4, 4) = out_4_4;
      out_Jh_x(5, 5) = out_5_5;
      out_Jh_x(6, 6) = out_6_6;
      out_Jh_x(7, 7) = out_7_7;
      out_Jh_x(8, 8) = out_8_8;
      out_Jh_x(9, 9) = out_9_9;
      out_Jh_x(10, 10) = out_10_10;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( ~, ~, ~, ~ )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      % No properties

      % Extract inputs

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(10, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out = in_domain( ~, ~, ~ )
      out = true;
    end % in_domain
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % CascadeOpAmp

% That's All Folks!
